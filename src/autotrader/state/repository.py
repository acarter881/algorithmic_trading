"""Data access layer for persisting trading events.

The :class:`TradingRepository` provides a clean interface for writing
trading data (orders, fills, signals, risk events, system events) to
the database.  It is injected into the :class:`TradingLoop` during
initialization.
"""

from __future__ import annotations

import datetime
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

import structlog

from autotrader.state.models import (
    DailyPnl,
    Fill,
    LeaderboardSnapshot,
    Order,
    RiskEvent,
    Signal,
    SystemEvent,
)

if TYPE_CHECKING:
    from sqlalchemy.orm import Session, sessionmaker

    from autotrader.execution.engine import TrackedOrder

logger = structlog.get_logger("autotrader.state.repository")


class TradingRepository:
    """Persists trading events to the database.

    All write methods open their own session and commit immediately.
    Errors are logged but never propagated — persistence must not crash
    the trading loop.
    """

    def __init__(self, session_factory: sessionmaker[Session]) -> None:
        self._session_factory = session_factory

    # ── Orders ───────────────────────────────────────────────────────

    def record_order(self, tracked: TrackedOrder) -> None:
        """Persist a submitted order."""
        try:
            with self._session_factory() as session:
                row = Order(
                    client_order_id=tracked.client_order_id,
                    kalshi_order_id=tracked.kalshi_order_id,
                    ticker=tracked.ticker,
                    event_ticker=tracked.ticker.rsplit("-", 1)[0] if "-" in tracked.ticker else tracked.ticker,
                    side=tracked.side,
                    price_cents=tracked.price_cents,
                    quantity=tracked.quantity,
                    filled_quantity=tracked.filled_quantity,
                    remaining_quantity=tracked.quantity - tracked.filled_quantity,
                    status=str(tracked.status),
                    strategy=tracked.strategy,
                    urgency=tracked.urgency,
                    rationale=tracked.rationale,
                    is_paper=tracked.is_paper,
                    filled_at=tracked.filled_at,
                    cancelled_at=tracked.cancelled_at,
                )
                session.add(row)
                session.commit()
                logger.debug("order_persisted", client_order_id=tracked.client_order_id)
        except Exception:
            logger.exception("order_persist_error", client_order_id=tracked.client_order_id)

    # ── Fills ────────────────────────────────────────────────────────

    def record_fill(self, fill_data: dict[str, Any], strategy: str) -> None:
        """Persist a fill event and update daily P&L."""
        try:
            with self._session_factory() as session:
                row = Fill(
                    order_client_id=fill_data.get("client_order_id", ""),
                    kalshi_fill_id=fill_data.get("kalshi_fill_id"),
                    ticker=fill_data["ticker"],
                    side=fill_data["side"],
                    action=fill_data.get("action", "buy"),
                    price_cents=fill_data["price_cents"],
                    quantity=fill_data["count"],
                    fee_cents=fill_data.get("fee_cents", 0),
                    is_taker=fill_data.get("is_taker", True),
                    is_paper=fill_data.get("is_paper", True),
                    strategy=strategy,
                    filled_at=self._parse_filled_at(fill_data.get("filled_at")),
                )
                session.add(row)
                session.commit()
                logger.debug("fill_persisted", ticker=fill_data["ticker"])

            # Update daily P&L
            self._update_daily_pnl(fill_data, strategy)
        except Exception:
            logger.exception("fill_persist_error", ticker=fill_data.get("ticker"))

    # ── Signals ──────────────────────────────────────────────────────

    def record_signal(
        self,
        signal_source: str,
        event_type: str,
        data: dict[str, Any],
        relevant_series: list[str],
        urgency: str,
        action: str = "",
    ) -> None:
        """Persist a signal generated by a signal source."""
        try:
            with self._session_factory() as session:
                row = Signal(
                    source=signal_source,
                    event_type=event_type,
                    urgency=urgency,
                    data=data,
                    relevant_series=relevant_series,
                    action_taken=action or None,
                )
                session.add(row)
                session.commit()
                logger.debug("signal_persisted", source=signal_source, event_type=event_type)
        except Exception:
            logger.exception("signal_persist_error", event_type=event_type)

    # ── Risk events ──────────────────────────────────────────────────

    def record_risk_event(self, check_name: str, order_data: dict[str, Any], reason: str) -> None:
        """Persist a risk check rejection."""
        try:
            with self._session_factory() as session:
                row = RiskEvent(
                    check_name=check_name,
                    proposed_order=order_data,
                    reason=reason,
                )
                session.add(row)
                session.commit()
                logger.debug("risk_event_persisted", check_name=check_name)
        except Exception:
            logger.exception("risk_event_persist_error", check_name=check_name)

    # ── Leaderboard snapshots ────────────────────────────────────────

    def record_leaderboard_snapshot(
        self,
        snapshot_data: dict[str, Any],
        source_url: str,
        model_count: int,
        top_model: str | None = None,
        top_org: str | None = None,
    ) -> None:
        """Persist a full leaderboard snapshot."""
        try:
            with self._session_factory() as session:
                row = LeaderboardSnapshot(
                    snapshot_data=snapshot_data,
                    source_url=source_url,
                    model_count=model_count,
                    top_model=top_model,
                    top_org=top_org,
                )
                session.add(row)
                session.commit()
                logger.debug("leaderboard_snapshot_persisted", model_count=model_count)
        except Exception:
            logger.exception("leaderboard_snapshot_persist_error")

    # ── System events ────────────────────────────────────────────────

    def record_system_event(
        self, event_type: str, details: dict[str, Any] | None = None, severity: str = "info"
    ) -> None:
        """Persist a system lifecycle event."""
        try:
            with self._session_factory() as session:
                row = SystemEvent(
                    event_type=event_type,
                    details=details or {},
                    severity=severity,
                )
                session.add(row)
                session.commit()
                logger.debug("system_event_persisted", event_type=event_type)
        except Exception:
            logger.exception("system_event_persist_error", event_type=event_type)

    # ── Daily P&L ────────────────────────────────────────────────────

    @staticmethod
    def _today_as_datetime() -> datetime.datetime:
        """Return today at midnight as a datetime (matches the DateTime column type)."""
        return datetime.datetime.combine(datetime.date.today(), datetime.time())

    def _update_daily_pnl(self, fill_data: dict[str, Any], strategy: str) -> None:
        """Update running daily P&L after a fill."""
        fill_timestamp = self._parse_filled_at(fill_data.get("filled_at"))
        day_start = datetime.datetime.combine(fill_timestamp.date(), datetime.time())
        day_end = day_start + datetime.timedelta(days=1)
        try:
            with self._session_factory() as session:
                row = session.query(DailyPnl).filter(DailyPnl.date == day_start, DailyPnl.strategy == strategy).first()
                fee_cents = fill_data.get("fee_cents", 0)
                is_paper = fill_data.get("is_paper", True)

                fills = (
                    session.query(Fill)
                    .filter(
                        Fill.strategy == strategy,
                        Fill.filled_at >= day_start,
                        Fill.filled_at < day_end,
                    )
                    .order_by(Fill.filled_at.asc(), Fill.id.asc())
                    .all()
                )
                realized_pnl_cents, unrealized_pnl_cents = self._compute_intraday_pnl_from_fills(fills)

                if row is None:
                    row = DailyPnl(
                        date=day_start,
                        strategy=strategy,
                        realized_pnl_cents=realized_pnl_cents,
                        unrealized_pnl_cents=unrealized_pnl_cents,
                        total_fees_cents=fee_cents,
                        trade_count=1,
                        is_paper=is_paper,
                    )
                    session.add(row)
                else:
                    row.realized_pnl_cents = realized_pnl_cents
                    row.unrealized_pnl_cents = unrealized_pnl_cents
                    row.total_fees_cents += fee_cents
                    row.trade_count += 1

                session.commit()
                logger.debug("daily_pnl_updated", strategy=strategy, date=str(day_start))
        except Exception:
            logger.exception("daily_pnl_update_error", strategy=strategy)

    @staticmethod
    def _parse_filled_at(raw_filled_at: Any) -> datetime.datetime:
        if isinstance(raw_filled_at, datetime.datetime):
            return raw_filled_at
        if isinstance(raw_filled_at, str):
            value = raw_filled_at.strip()
            if value.endswith("Z"):
                value = value[:-1] + "+00:00"
            try:
                parsed = datetime.datetime.fromisoformat(value)
                return parsed.replace(tzinfo=None) if parsed.tzinfo else parsed
            except ValueError:
                logger.warning("fill_timestamp_parse_failed", filled_at=raw_filled_at)
        return datetime.datetime.utcnow()

    @dataclass
    class _TickerPnlState:
        qty: int = 0
        avg_cost_cents: float = 0.0
        mark_price_cents: float = 0.0

    @classmethod
    def _compute_intraday_pnl_from_fills(cls, fills: list[Fill]) -> tuple[int, int]:
        realized = 0.0
        per_ticker_state: dict[str, TradingRepository._TickerPnlState] = {}

        for fill in fills:
            state = per_ticker_state.setdefault(fill.ticker, cls._TickerPnlState())
            delta_qty, trade_yes_price = cls._yes_equivalent_trade(fill)
            if delta_qty == 0:
                continue

            state.mark_price_cents = trade_yes_price
            realized += cls._apply_fill_to_state(state, delta_qty, trade_yes_price)
            realized -= float(fill.fee_cents)

        unrealized = 0.0
        for state in per_ticker_state.values():
            if state.qty > 0:
                unrealized += (state.mark_price_cents - state.avg_cost_cents) * state.qty
            elif state.qty < 0:
                unrealized += (state.avg_cost_cents - state.mark_price_cents) * abs(state.qty)

        return int(round(realized)), int(round(unrealized))

    @staticmethod
    def _yes_equivalent_trade(fill: Fill) -> tuple[int, float]:
        side = str(fill.side).lower()
        action = str(fill.action).lower()

        signed_qty = fill.quantity if side == "yes" else -fill.quantity
        if action == "sell":
            signed_qty = -signed_qty

        yes_equivalent_price = float(fill.price_cents if side == "yes" else 100 - fill.price_cents)
        return signed_qty, yes_equivalent_price

    @staticmethod
    def _apply_fill_to_state(state: _TickerPnlState, delta_qty: int, trade_price_cents: float) -> float:
        current_qty = state.qty
        if current_qty == 0 or (current_qty > 0 and delta_qty > 0) or (current_qty < 0 and delta_qty < 0):
            new_qty = current_qty + delta_qty
            state.avg_cost_cents = (abs(current_qty) * state.avg_cost_cents + abs(delta_qty) * trade_price_cents) / abs(
                new_qty
            )
            state.qty = new_qty
            return 0.0

        closing_qty = min(abs(current_qty), abs(delta_qty))
        if current_qty > 0:
            realized = (trade_price_cents - state.avg_cost_cents) * closing_qty
        else:
            realized = (state.avg_cost_cents - trade_price_cents) * closing_qty

        new_qty = current_qty + delta_qty
        if new_qty == 0:
            state.avg_cost_cents = 0.0
        elif (current_qty > 0 > new_qty) or (current_qty < 0 < new_qty):
            state.avg_cost_cents = trade_price_cents
        state.qty = new_qty

        return realized

    # ── Queries ──────────────────────────────────────────────────────

    def get_daily_pnl(self, strategy: str, date: datetime.date | None = None) -> DailyPnl | None:
        """Fetch daily P&L for a strategy (defaults to today)."""
        target_dt = datetime.datetime.combine(date, datetime.time()) if date is not None else self._today_as_datetime()
        try:
            with self._session_factory() as session:
                return session.query(DailyPnl).filter(DailyPnl.date == target_dt, DailyPnl.strategy == strategy).first()
        except Exception:
            logger.exception("daily_pnl_query_error", strategy=strategy)
            return None

    def get_today_trade_count(self, strategy: str) -> int:
        """Get total trades today for a strategy."""
        pnl = self.get_daily_pnl(strategy)
        return pnl.trade_count if pnl else 0

    def get_pnl_history(
        self,
        strategy: str | None = None,
        days: int = 7,
    ) -> list[DailyPnl]:
        """Fetch daily P&L rows for the last *days* days, optionally filtered by strategy."""
        cutoff = datetime.datetime.combine(
            datetime.date.today() - datetime.timedelta(days=days - 1),
            datetime.time(),
        )
        try:
            with self._session_factory() as session:
                query = session.query(DailyPnl).filter(DailyPnl.date >= cutoff)
                if strategy:
                    query = query.filter(DailyPnl.strategy == strategy)
                rows = query.order_by(DailyPnl.date.asc(), DailyPnl.strategy.asc()).all()
                # Detach from session so callers can use them freely
                session.expunge_all()
                return list(rows)
        except Exception:
            logger.exception("pnl_history_query_error", strategy=strategy, days=days)
            return []

    def get_all_fills(
        self,
        strategy: str | None = None,
        days: int = 7,
    ) -> list[Fill]:
        """Fetch fill records for the last *days* days."""
        cutoff = datetime.datetime.combine(
            datetime.date.today() - datetime.timedelta(days=days - 1),
            datetime.time(),
        )
        try:
            with self._session_factory() as session:
                query = session.query(Fill).filter(Fill.filled_at >= cutoff)
                if strategy:
                    query = query.filter(Fill.strategy == strategy)
                rows = query.order_by(Fill.filled_at.asc()).all()
                session.expunge_all()
                return list(rows)
        except Exception:
            logger.exception("fills_query_error", strategy=strategy, days=days)
            return []

    def get_net_positions_by_ticker(self, strategy: str, is_paper: bool | None = None) -> dict[str, int]:
        """Compute current net YES-equivalent position by ticker for a strategy.

        When ``is_paper`` is provided, only fills matching that execution mode
        are considered.
        """
        try:
            with self._session_factory() as session:
                query = session.query(Fill).filter(Fill.strategy == strategy)
                if is_paper is not None:
                    query = query.filter(Fill.is_paper == is_paper)
                fills = query.order_by(Fill.filled_at.asc(), Fill.id.asc()).all()

            positions: dict[str, int] = {}
            for fill in fills:
                delta_qty, _ = self._yes_equivalent_trade(fill)
                if delta_qty == 0:
                    continue
                positions[fill.ticker] = positions.get(fill.ticker, 0) + delta_qty

            return {ticker: qty for ticker, qty in positions.items() if qty != 0}
        except Exception:
            logger.exception("net_positions_query_error", strategy=strategy, is_paper=is_paper)
            return {}
