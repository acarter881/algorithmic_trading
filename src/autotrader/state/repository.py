"""Data access layer for persisting trading events.

The :class:`TradingRepository` provides a clean interface for writing
trading data (orders, fills, signals, risk events, system events) to
the database.  It is injected into the :class:`TradingLoop` during
initialization.
"""

from __future__ import annotations

import datetime
from typing import TYPE_CHECKING, Any

import structlog

from autotrader.state.models import (
    DailyPnl,
    Fill,
    LeaderboardSnapshot,
    Order,
    RiskEvent,
    Signal,
    SystemEvent,
)

if TYPE_CHECKING:
    from sqlalchemy.orm import Session, sessionmaker

    from autotrader.execution.engine import TrackedOrder

logger = structlog.get_logger("autotrader.state.repository")


class TradingRepository:
    """Persists trading events to the database.

    All write methods open their own session and commit immediately.
    Errors are logged but never propagated — persistence must not crash
    the trading loop.
    """

    def __init__(self, session_factory: sessionmaker[Session]) -> None:
        self._session_factory = session_factory

    # ── Orders ───────────────────────────────────────────────────────

    def record_order(self, tracked: TrackedOrder) -> None:
        """Persist a submitted order."""
        try:
            with self._session_factory() as session:
                row = Order(
                    client_order_id=tracked.client_order_id,
                    kalshi_order_id=tracked.kalshi_order_id,
                    ticker=tracked.ticker,
                    event_ticker=tracked.ticker.rsplit("-", 1)[0] if "-" in tracked.ticker else tracked.ticker,
                    side=tracked.side,
                    price_cents=tracked.price_cents,
                    quantity=tracked.quantity,
                    filled_quantity=tracked.filled_quantity,
                    remaining_quantity=tracked.quantity - tracked.filled_quantity,
                    status=str(tracked.status),
                    strategy=tracked.strategy,
                    urgency=tracked.urgency,
                    rationale=tracked.rationale,
                    is_paper=tracked.is_paper,
                    filled_at=tracked.filled_at,
                    cancelled_at=tracked.cancelled_at,
                )
                session.add(row)
                session.commit()
                logger.debug("order_persisted", client_order_id=tracked.client_order_id)
        except Exception:
            logger.exception("order_persist_error", client_order_id=tracked.client_order_id)

    # ── Fills ────────────────────────────────────────────────────────

    def record_fill(self, fill_data: dict[str, Any], strategy: str) -> None:
        """Persist a fill event and update daily P&L."""
        try:
            with self._session_factory() as session:
                row = Fill(
                    order_client_id=fill_data.get("client_order_id", ""),
                    kalshi_fill_id=fill_data.get("kalshi_fill_id"),
                    ticker=fill_data["ticker"],
                    side=fill_data["side"],
                    price_cents=fill_data["price_cents"],
                    quantity=fill_data["count"],
                    fee_cents=fill_data.get("fee_cents", 0),
                    is_taker=fill_data.get("is_taker", True),
                    is_paper=fill_data.get("is_paper", True),
                    strategy=strategy,
                )
                session.add(row)
                session.commit()
                logger.debug("fill_persisted", ticker=fill_data["ticker"])

            # Update daily P&L
            self._update_daily_pnl(fill_data, strategy)
        except Exception:
            logger.exception("fill_persist_error", ticker=fill_data.get("ticker"))

    # ── Signals ──────────────────────────────────────────────────────

    def record_signal(
        self,
        signal_source: str,
        event_type: str,
        data: dict[str, Any],
        relevant_series: list[str],
        urgency: str,
        action: str = "",
    ) -> None:
        """Persist a signal generated by a signal source."""
        try:
            with self._session_factory() as session:
                row = Signal(
                    source=signal_source,
                    event_type=event_type,
                    urgency=urgency,
                    data=data,
                    relevant_series=relevant_series,
                    action_taken=action or None,
                )
                session.add(row)
                session.commit()
                logger.debug("signal_persisted", source=signal_source, event_type=event_type)
        except Exception:
            logger.exception("signal_persist_error", event_type=event_type)

    # ── Risk events ──────────────────────────────────────────────────

    def record_risk_event(self, check_name: str, order_data: dict[str, Any], reason: str) -> None:
        """Persist a risk check rejection."""
        try:
            with self._session_factory() as session:
                row = RiskEvent(
                    check_name=check_name,
                    proposed_order=order_data,
                    reason=reason,
                )
                session.add(row)
                session.commit()
                logger.debug("risk_event_persisted", check_name=check_name)
        except Exception:
            logger.exception("risk_event_persist_error", check_name=check_name)

    # ── Leaderboard snapshots ────────────────────────────────────────

    def record_leaderboard_snapshot(
        self,
        snapshot_data: dict[str, Any],
        source_url: str,
        model_count: int,
        top_model: str | None = None,
        top_org: str | None = None,
    ) -> None:
        """Persist a full leaderboard snapshot."""
        try:
            with self._session_factory() as session:
                row = LeaderboardSnapshot(
                    snapshot_data=snapshot_data,
                    source_url=source_url,
                    model_count=model_count,
                    top_model=top_model,
                    top_org=top_org,
                )
                session.add(row)
                session.commit()
                logger.debug("leaderboard_snapshot_persisted", model_count=model_count)
        except Exception:
            logger.exception("leaderboard_snapshot_persist_error")

    # ── System events ────────────────────────────────────────────────

    def record_system_event(
        self, event_type: str, details: dict[str, Any] | None = None, severity: str = "info"
    ) -> None:
        """Persist a system lifecycle event."""
        try:
            with self._session_factory() as session:
                row = SystemEvent(
                    event_type=event_type,
                    details=details or {},
                    severity=severity,
                )
                session.add(row)
                session.commit()
                logger.debug("system_event_persisted", event_type=event_type)
        except Exception:
            logger.exception("system_event_persist_error", event_type=event_type)

    # ── Daily P&L ────────────────────────────────────────────────────

    @staticmethod
    def _today_as_datetime() -> datetime.datetime:
        """Return today at midnight as a datetime (matches the DateTime column type)."""
        return datetime.datetime.combine(datetime.date.today(), datetime.time())

    def _update_daily_pnl(self, fill_data: dict[str, Any], strategy: str) -> None:
        """Update running daily P&L after a fill."""
        today_dt = self._today_as_datetime()
        try:
            with self._session_factory() as session:
                row = session.query(DailyPnl).filter(DailyPnl.date == today_dt, DailyPnl.strategy == strategy).first()
                fee_cents = fill_data.get("fee_cents", 0)
                is_paper = fill_data.get("is_paper", True)

                if row is None:
                    row = DailyPnl(
                        date=today_dt,
                        strategy=strategy,
                        total_fees_cents=fee_cents,
                        trade_count=1,
                        is_paper=is_paper,
                    )
                    session.add(row)
                else:
                    row.total_fees_cents += fee_cents
                    row.trade_count += 1

                session.commit()
                logger.debug("daily_pnl_updated", strategy=strategy, date=str(today_dt))
        except Exception:
            logger.exception("daily_pnl_update_error", strategy=strategy)

    # ── Queries ──────────────────────────────────────────────────────

    def get_daily_pnl(self, strategy: str, date: datetime.date | None = None) -> DailyPnl | None:
        """Fetch daily P&L for a strategy (defaults to today)."""
        target_dt = datetime.datetime.combine(date, datetime.time()) if date is not None else self._today_as_datetime()
        try:
            with self._session_factory() as session:
                return session.query(DailyPnl).filter(DailyPnl.date == target_dt, DailyPnl.strategy == strategy).first()
        except Exception:
            logger.exception("daily_pnl_query_error", strategy=strategy)
            return None

    def get_today_trade_count(self, strategy: str) -> int:
        """Get total trades today for a strategy."""
        pnl = self.get_daily_pnl(strategy)
        return pnl.trade_count if pnl else 0
